# The MIT License (MIT)
#
# Copyright © 2024 The pyTooling Authors
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
# documentation files (the “Software”), to deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
# WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
name: Upload Artifact (Preserve File Permissions)
branding:
  icon: upload
  color: yellow
description: Tarball files before uploading the artifact to preserve file privileges.
author: Patrick Lehmann (@Paebbels)

inputs:
  name:
    description: | 
      Name of the artifact to upload.
    type: string
    required: false
    default: 'artifact'
  working-directory:
#    description:
    type: string
    required: false
    default: ''
  path:
    description: |
      A file, directory or wildcard pattern that describes what to upload
    type: string
    required: true
  if-no-files-found:
    description: |
      The desired behavior if no files are found using the provided path.
      Available Options:
        warn: Output a warning but do not fail the action
        error: Fail the action with an error message
        ignore: Do not output any warnings or errors, the action does not fail
    type: string
    required: false
    default: 'warn'
  retention-days:
    description: |
      Duration after which artifact will expire in days. 0 means using default retention.
      Minimum 1 day.
      Maximum 90 days unless changed from the repository settings page.
      Defaults to repository settings.
    type: number
    required: false
  compression-level:
    description: |
      The level of compression for Zlib to be applied to the artifact archive.
      The value can range from 0 to 9.
      For large files that are not easily compressed, a value of 0 is recommended for significantly faster uploads.
    type: number
    required: false
    default: 6
  overwrite:
    description: |
      If true, an artifact with a matching name will be deleted before a new one is uploaded.
      If false, the action will fail if an artifact for the given name already exists.
      Does not fail if the artifact does not exist.
    type: boolean
    required: false
    default: false
  include-hidden-files:
    description: |
      Whether to include hidden files in the provided path in the artifact
      The file contents of any hidden files in the path should be validated before
      enabled this to avoid uploading sensitive information.
    type: boolean
    required: false
    default: false
  tarball-name:
    type: string
    required: false
    default: '__pyTooling_upload_artifact__.tar'

outputs:
  artifact-id:
    description: "GitHub ID of an Artifact, can be used by the REST API"
    value: ${{ steps.upload.outputs.artifact-id }}
  artifact-url:
    description: |
      URL to download an Artifact. Can be used in many scenarios such as linking to
      artifacts in issues or pull requests. Users must be logged-in in order for this
      URL to work. This URL is valid as long as the artifact has not expired or the
      artifact, run or repository have not been deleted.
    value: ${{ steps.upload.outputs.artifact-url }}

runs:
  using: composite
  steps:
    - name: Create tarball from given file patterns
      id: prepare
      shell: bash
      run: |
        set +e

        ANSI_LIGHT_RED="\e[91m"
        ANSI_LIGHT_GREEN="\e[92m"
        ANSI_CYAN="\e[36m"
        ANSI_NOCOLOR="\e[0m"

        if [[ "${{ inputs.working-directory }}" != "" ]]; then
          echo -n "Changing artifact root directory to '${{ inputs.working-directory }}' ... "
          if [[ -d "${{ inputs.working-directory }}" ]]; then
            pushd "${{ inputs.working-directory }}" > /dev/null
            if [[ $? -ne 0 ]]; then
              echo -e "${ANSI_LIGHT_RED}[FAILED]${ANSI_NOCOLOR}"
              exit 1
            else
              echo -e "${ANSI_LIGHT_GREEN}[OK]${ANSI_NOCOLOR}"
        
              dir="${{ inputs.working-directory }}"
              tarDirectory=""
              while [[ "${dir}" != "." ]]; do
                tarDirectory="../${tarDirectory}"
                dir=$(dirname -- "${dir}")
              done
              echo "  tarDirectory: ${tarDirectory}"
            fi
          else
            echo -e "echo -e ${ANSI_LIGHT_RED}[NO DIRECTORY]${ANSI_NOCOLOR}"
            exit 1
          fi
        else
          tarDirectory=""
        fi

        echo -n "Convert provided file patterns to a single line ... "
        PATTERNS=()
        while IFS=$'\r\n' read -r pattern; do
          # skip empty or comment lines
          [[ "${pattern}" == "" || "${pattern:0:1}" == "#" ]] && continue

          PATTERNS+=("$pattern")
        done <<<'${{ inputs.path }}'
        echo -e "${ANSI_LIGHT_GREEN}[DONE]${ANSI_NOCOLOR}"
        
        print_files_unique() {
          for i in "$@"; do
            compgen -G "$i" || true
          done | sort | uniq
        }
        
        echo -e "Checking tar ($(which tar)): ${ANSI_CYAN}$(tar --version | head -n 1)${ANSI_NOCOLOR}"
        echo -n "Assemble OS specific tar command line options ... "
        if [[ "${{ runner.os }}" == "macOS" ]]; then
          echo -e "${ANSI_Y}[macOS]${ANSI_NOCOLOR}"
          filesFrom=("-T")
        elif [[ "${{ runner.os }}" == "Linux" || "${{ runner.os }}" == "Windows" ]]; then
          echo -e "${ANSI_LIGHT_GREEN}[${{ runner.os }}]${ANSI_NOCOLOR}"
          filesFrom=("--verbatim-files-from" "--files-from")
        else
          echo -e "${ANSI_LIGHT_RED}[UNSUPPORTED]${ANSI_NOCOLOR}"
          exit 1
        fi
        
        echo -n "Creating temporary tarball '${tarDirectory}${{ inputs.tarball-name }}' ... "
        tar -cf "${tarDirectory}${{ inputs.tarball-name }}" --owner=0 --group=0 "${filesFrom[@]}" <(print_files_unique "${PATTERNS[@]}")
        if [[ $? -ne 0 ]]; then
          echo -e "${ANSI_LIGHT_RED}[FAILED]${ANSI_NOCOLOR}"
          exit 1
        else
          echo -e "${ANSI_LIGHT_GREEN}[OK]${ANSI_NOCOLOR}"
        fi
        
        echo -e "${ANSI_CYAN}Files collected: $(tar -tf "${tarDirectory}${{ inputs.tarball-name }}" | wc -l)${ANSI_NOCOLOR}"

    # https://github.com/actions/upload-artifact
    - name: Upload artifact
      id: upload
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.name }}
        path: ${{ inputs.tarball-name }}
        if-no-files-found: ${{ inputs.if-no-files-found }}
        retention-days: ${{ inputs.retention-days }}
        compression-level: ${{ inputs.compression-level }}
        overwrite: ${{ inputs.overwrite }}
        include-hidden-files: ${{ inputs.include-hidden-files }}

    - name: Remove temporary tarball
      id: cleanup
      shell: bash
      run: |
        set +e

        ANSI_LIGHT_RED="\e[91m"
        ANSI_LIGHT_GREEN="\e[92m"
        ANSI_NOCOLOR="\e[0m"
        
        echo -n "Removing temporary tarball ... "
        rm -f "${{ inputs.tarball-name }}"
        if [[ $? -ne 0 ]]; then
          echo -e "${ANSI_LIGHT_RED}[FAILED]${ANSI_NOCOLOR}"
        else
          echo -e "${ANSI_LIGHT_GREEN}[OK]${ANSI_NOCOLOR}"
        fi
